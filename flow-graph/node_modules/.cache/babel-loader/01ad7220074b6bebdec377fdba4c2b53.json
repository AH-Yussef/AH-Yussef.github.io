{"remainingRequest":"/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/node_modules/babel-loader/lib/index.js!/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/node_modules/eslint-loader/index.js??ref--13-0!/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/src/solvingAlgo/Transfer_ function.js","dependencies":[{"path":"/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/src/solvingAlgo/Transfer_ function.js","mtime":1619820357070},{"path":"/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9Vc2Vycy9hbGloYXNzYW4vVGhlX0xPTC9Qcm9qZWN0cy9jb2xsYWdlX3JlbGF0ZWQvU2Vjb25kWWVhci9Db250cm9sX1N5c3RlbXMvc2lnbmFsLWZsb3ctZ3JhcGgtc29sdmVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvVXNlcnMvYWxpaGFzc2FuL1RoZV9MT0wvUHJvamVjdHMvY29sbGFnZV9yZWxhdGVkL1NlY29uZFllYXIvQ29udHJvbF9TeXN0ZW1zL3NpZ25hbC1mbG93LWdyYXBoLXNvbHZlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyI7CmV4cG9ydCBmdW5jdGlvbiB0cmFuc2ZlckZ1bmN0aW9uKHBhdGhzLCBsb29wcykgewogIC8vIGdldCB0aGUgbG9vcCBmcm9tIGxvb3BzIG9iamVjdCBhbmQgcGF0aCBmcm9tIHBhdGhzIG9iamVjdAogIHZhciBwYXRoID0gcGF0aHMucGF0aHM7CiAgdmFyIHBhdGhHYWluID0gcGF0aHMuZ2FpbnM7CiAgdmFyIGxvb3AgPSBsb29wcy5sb29wczsKICB2YXIgbG9vcEdhaW4gPSBsb29wcy5nYWluczsKICB2YXIgcGF0aHNOdW1iZXIgPSBwYXRoLmxlbmd0aDsgLy9NYXNvbiBydWxlID0gMS9kZXRlciAqIHN1bVtwYXRoR2FpbihpKSAqIGRldGVyKGkpXQogIC8vMXN0OiBjYWxjdWxhdGUgZGVsdGEgc3lzdGVtCgogIHZhciBzeXN0ZW1EZXRlcm1pbmFudCA9IGRlbHRhQ2FsY3VsYXRvcihsb29wLCBsb29wR2Fpbik7IC8vMm5kOiBjYWxjdWxhdGUgZGVsdGFzIHBhdGgKCiAgdmFyIGRlbHRhcyA9IGRlbHRhc09mUGF0aHMocGF0aCwgbG9vcCwgbG9vcEdhaW4pOyAvLzNyZDogY2FsY3VsYXRlIHN1bVtwYXRoR2FpbihpKSAqIGRldGVyKGkpXQoKICB2YXIgdmFyaWFibGVTdW0gPSAwOwoKICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzTnVtYmVyOyBpKyspIHsKICAgIHZhcmlhYmxlU3VtICs9IHBhdGhHYWluW2ldICogZGVsdGFzW2ldOwogIH0gLy80dGggcHV0IGl0IGFsbCB0b2dldGhlciB1c2luZyBtYXNvbidzIHJ1bGUKCgogIHZhciB0cmFuc2ZlckZ1bmN0aW9uVmFsdWUgPSAxIC8gc3lzdGVtRGV0ZXJtaW5hbnQgKiB2YXJpYWJsZVN1bTsKICByZXR1cm4gewogICAgdHJhbnNmZXJGdW5jdGlvbjogdHJhbnNmZXJGdW5jdGlvblZhbHVlLAogICAgZGVsdGFzOiBkZWx0YXMsCiAgICBzeXN0ZW1EZWx0YTogc3lzdGVtRGV0ZXJtaW5hbnQKICB9Owp9CgpmdW5jdGlvbiBkZWx0YUNhbGN1bGF0b3IobG9vcCwgbG9vcEdhaW4pIHsKICB2YXIgZGVsdGEgPSAxOyAvL2luZGl2aWR1YWwgbG9vcAoKICB2YXIgaW5kaXZpZHVhbEdhaW5zID0gMDsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29wLmxlbmd0aDsgaSsrKSB7CiAgICBpbmRpdmlkdWFsR2FpbnMgKz0gbG9vcEdhaW5baV07CiAgfQoKICBkZWx0YSAtPSBpbmRpdmlkdWFsR2FpbnM7CiAgdmFyIGluZGl2aWR1YWxzQ291bnRlciA9IGxvb3AubGVuZ3RoOwoKICB2YXIgY3VycmVudENvbWJpbmF0aW9ucyA9IF90b0NvbnN1bWFibGVBcnJheShsb29wKTsKCiAgdmFyIGN1cnJlbnRDb21iaW5hdGlvbnNHYWlucyA9IF90b0NvbnN1bWFibGVBcnJheShsb29wR2Fpbik7IC8vZ2V0dGluZyBjb21iaW5hdGlvbnMgb2YgZWFjaCBpbmRlcGVuZGVudCBsb29wIHNpbmcKCgogIHZhciBzaWduID0gLTE7CgogIHdoaWxlIChpbmRpdmlkdWFsc0NvdW50ZXIgPiAwKSB7CiAgICBzaWduICo9IC0xOwogICAgaW5kaXZpZHVhbHNDb3VudGVyID0gMDsKICAgIHZhciBjb21iaW5hdGlvbnMgPSBbXTsKICAgIHZhciBjb21iaW5hdGlvbnNHYWlucyA9IFtdOwoKICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdXJyZW50Q29tYmluYXRpb25zLmxlbmd0aDsgX2krKykgewogICAgICBmb3IgKHZhciBqID0gX2kgKyAxOyBqIDwgbG9vcC5sZW5ndGg7IGorKykgewogICAgICAgIC8vaWYgdHdvIGxvb3BzL2NvbWJpbmF0aW9ucyBmb3VuZCBub24gY29ubmVjdGluZyB0aGVuIHdlIGFkZCB0aGUgbmV3IGNvbmNhdCB0byBiZSBjaGVja2VkIHdpdGggdGhlIG5leHQgY29uY2F0CiAgICAgICAgLy9hbmQgdGhlIGdhaW4gcmVzdWx0aW5nIGJlY29tZXMgdGhlIG5ldyBnYWluCiAgICAgICAgaWYgKGlzSW5kZXBlbmRlbnQoY3VycmVudENvbWJpbmF0aW9uc1tfaV0sIGxvb3Bbal0pKSB7CiAgICAgICAgICBjb21iaW5hdGlvbnMucHVzaChjb25jYXRlbmF0ZU5vZGVzKGN1cnJlbnRDb21iaW5hdGlvbnNbX2ldLCBsb29wW2pdKSk7CiAgICAgICAgICBjb21iaW5hdGlvbnNHYWlucy5wdXNoKGN1cnJlbnRDb21iaW5hdGlvbnNHYWluc1tfaV0gKiBsb29wR2FpbltqXSk7CiAgICAgICAgICBpbmRpdmlkdWFsc0NvdW50ZXIrKzsgLy8gYWRkL3N1YnRyYWN0IHRoZSByZXN1bHRpbmcgZ2FpbiB0byBkZWx0YQoKICAgICAgICAgIGRlbHRhICs9IHNpZ24gKiBjdXJyZW50Q29tYmluYXRpb25zR2FpbnNbX2ldICogbG9vcEdhaW5bal07CiAgICAgICAgfQogICAgICB9CiAgICB9IC8vbWFraW5nIHRoZSByZXN1bHRpbmcgY29uY2F0aW5hdGlvbiB0aGUgbmV3IGN1cnJlbnQgY29tYmluYXRpb25zIHRvIGNoZWNrIHdpdGggaW5kaXZpZHVhbHMgdG8gbWFrZSBuZXcgY29uYwoKCiAgICBjdXJyZW50Q29tYmluYXRpb25zID0gW10uY29uY2F0KGNvbWJpbmF0aW9ucyk7CiAgICBjdXJyZW50Q29tYmluYXRpb25zR2FpbnMgPSBbXS5jb25jYXQoY29tYmluYXRpb25zR2FpbnMpOwogIH0KCiAgcmV0dXJuIGRlbHRhOwp9CgpmdW5jdGlvbiBkZWx0YXNPZlBhdGhzKHBhdGgsIGxvb3AsIGxvb3BHYWluKSB7CiAgdmFyIGRlbHRhcyA9IFtdOwogIHZhciByZW1haW5pbmdMb29wcyA9IFtdOwogIHZhciByZW1haW5pbmdHYWlucyA9IFtdOyAvLyB0byBjaGVjayBmb3IgbG9vcHMgdGhhdCB0b3VjaCBhIGNlcnRhaW4gcGF0aCwgaWYgdGhleSBkbyB0aGV5IHdpbGwgYmUgZGlzY2FyZGVkCgogIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykgewogICAgcmVtYWluaW5nTG9vcHMgPSBbXTsKICAgIHJlbWFpbmluZ0dhaW5zID0gW107CgogICAgZm9yICh2YXIgaiA9IDA7IGogPCBsb29wLmxlbmd0aDsgaisrKSB7CiAgICAgIGlmIChpc0luZGVwZW5kZW50KHBhdGhbaV0sIGxvb3Bbal0pKSB7CiAgICAgICAgcmVtYWluaW5nTG9vcHMucHVzaChsb29wW2pdKTsKICAgICAgICByZW1haW5pbmdHYWlucy5wdXNoKGxvb3BHYWluW2pdKTsKICAgICAgfQogICAgfQoKICAgIGRlbHRhcy5wdXNoKGRlbHRhQ2FsY3VsYXRvcihyZW1haW5pbmdMb29wcywgcmVtYWluaW5nR2FpbnMpKTsKICB9CgogIHJldHVybiBkZWx0YXM7Cn0gLy8qKioqKioqKioqSEVMUEVSIEZVTkNUSU9OUwoKCmZ1bmN0aW9uIGlzSW5kZXBlbmRlbnQobm9kZXMxLCBub2RlczIpIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzMS5sZW5ndGg7IGkrKykgewogICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlczIubGVuZ3RoOyBqKyspIHsKICAgICAgaWYgKG5vZGVzMVtpXSA9PSBub2RlczJbal0pIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb25jYXRlbmF0ZU5vZGVzKGxvb3AxLCBsb29wMikgewogIHZhciBub2RlU2V0ID0gbmV3IFNldCgpOwoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb3AxLmxlbmd0aDsgaSsrKSB7CiAgICBub2RlU2V0LmFkZChsb29wMVtpXSk7CiAgfQoKICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsb29wMi5sZW5ndGg7IF9pMisrKSB7CiAgICBub2RlU2V0LmFkZChsb29wMltfaTJdKTsKICB9CgogIHZhciBub2RlQXJyYXkgPSBbXTsKCiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vZGVTZXQpLAogICAgICBfc3RlcDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7CiAgICAgIG5vZGVBcnJheS5wdXNoKG5vZGUpOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yLmYoKTsKICB9CgogIHJldHVybiBub2RlQXJyYXk7Cn0gLy8gY29uc3QgbG9vcHMgPSB7Ci8vICAgICBsb29wIDogW1szLDQsM10sIFs0LDUsNF0sIFs2LDZdLCBbMiw2LDUsMl0sIFsyLDMsNCw1LDJdXSwKLy8gICAgIGxvb3BHYWluIDogWy0xMCwtNCwtMSwtMjAsLTEwMF0KLy8gfTsKLy8gY29uc3QgcGF0aHMgPSB7Ci8vICAgICBwYXRoIDogW1sxLDIsMyw0LDVdLCBbMSwyLDYsNV1dLAovLyAgICAgcGF0aEdhaW4gOiBbMTAwLCAyMF0KLy8gfQovLyBjb25zb2xlLmxvZygidGVzdC0tLS0tLS0tLS0tLS0tLS0tLS0tLSIpOwovLyBjb25zb2xlLmxvZyh0cmFuc2ZlckZ1bmN0aW9uKHBhdGhzLCBsb29wcykpOw=="},{"version":3,"sources":["/Users/alihassan/The_LOL/Projects/collage_related/SecondYear/Control_Systems/signal-flow-graph-solver/src/solvingAlgo/Transfer_ function.js"],"names":["transferFunction","paths","loops","path","pathGain","gains","loop","loopGain","pathsNumber","length","systemDeterminant","deltaCalculator","deltas","deltasOfPaths","variableSum","i","transferFunctionValue","systemDelta","delta","individualGains","individualsCounter","currentCombinations","currentCombinationsGains","sign","combinations","combinationsGains","j","isIndependent","push","concatenateNodes","remainingLoops","remainingGains","nodes1","nodes2","loop1","loop2","nodeSet","Set","add","nodeArray","node"],"mappings":"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","sourcesContent":["export function transferFunction(paths, loops){\n    // get the loop from loops object and path from paths object\n    const path = paths.paths;\n    const pathGain = paths.gains;\n\n    const loop = loops.loops;\n    const loopGain = loops.gains;\n    \n    const pathsNumber = path.length;\n\n    //Mason rule = 1/deter * sum[pathGain(i) * deter(i)]\n\n    //1st: calculate delta system\n    const systemDeterminant = deltaCalculator(loop, loopGain);\n\n    //2nd: calculate deltas path\n    const deltas = deltasOfPaths(path, loop, loopGain);\n    //3rd: calculate sum[pathGain(i) * deter(i)]\n    let variableSum = 0;\n    for(let i=0; i<pathsNumber; i++){\n        variableSum += pathGain[i] * deltas[i];\n    }\n    \n    //4th put it all together using mason's rule\n    const transferFunctionValue = (1/systemDeterminant)*variableSum;\n    return {\n        transferFunction : transferFunctionValue,\n        deltas: deltas,\n        systemDelta: systemDeterminant\n    };\n}\n\nfunction deltaCalculator(loop, loopGain){\n    let delta = 1;\n    //individual loop\n    let individualGains = 0;\n    for(let i=0; i<loop.length; i++){\n        individualGains += loopGain[i];\n    }\n    delta -= individualGains;\n    let individualsCounter = loop.length;\n    let currentCombinations = [...loop];\n    let currentCombinationsGains = [...loopGain];\n\n    //getting combinations of each independent loop sing\n    let sign = -1;\n    while(individualsCounter > 0){\n        sign *= -1;\n        individualsCounter = 0;\n        let combinations = [];\n        let combinationsGains = [];\n        for(let i=0; i<currentCombinations.length; i++){\n            for(let j=i+1; j<loop.length; j++){\n                //if two loops/combinations found non connecting then we add the new concat to be checked with the next concat\n                //and the gain resulting becomes the new gain\n                if(isIndependent(currentCombinations[i], loop[j])){\n                    combinations.push(concatenateNodes(currentCombinations[i], loop[j]));\n                    combinationsGains.push(currentCombinationsGains[i]*loopGain[j]);\n                    individualsCounter++;\n                    // add/subtract the resulting gain to delta\n                    delta += sign*currentCombinationsGains[i]*loopGain[j];\n                }\n            }\n        }\n        //making the resulting concatination the new current combinations to check with individuals to make new conc\n        currentCombinations = [...combinations];\n        currentCombinationsGains = [...combinationsGains];\n    }\n    return delta;\n}\n\nfunction deltasOfPaths(path, loop, loopGain){\n    let deltas = [];\n    let remainingLoops = [];\n    let remainingGains = [];\n    // to check for loops that touch a certain path, if they do they will be discarded\n    for(let i=0; i<path.length; i++){\n        remainingLoops = [];\n        remainingGains = [];\n        for(let j=0; j<loop.length; j++){\n            if(isIndependent(path[i], loop[j])){\n                remainingLoops.push(loop[j]);\n                remainingGains.push(loopGain[j]);\n            }\n        }\n        deltas.push(deltaCalculator(remainingLoops, remainingGains));\n    }\n    return deltas;\n}\n\n//**********HELPER FUNCTIONS\nfunction isIndependent(nodes1, nodes2){\n    for(let i=0; i<nodes1.length; i++){\n        for(let j=0; j<nodes2.length; j++){\n            if(nodes1[i] == nodes2[j]){\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction concatenateNodes(loop1, loop2){\n    let nodeSet = new Set();\n    for(let i=0; i<loop1.length; i++) nodeSet.add(loop1[i]);\n    for(let i=0; i<loop2.length; i++) nodeSet.add(loop2[i]);\n\n    let nodeArray = [];\n    for(let node of nodeSet){\n        nodeArray.push(node);\n    }\n    return nodeArray;\n}\n\n// const loops = {\n//     loop : [[3,4,3], [4,5,4], [6,6], [2,6,5,2], [2,3,4,5,2]],\n//     loopGain : [-10,-4,-1,-20,-100]\n// };\n// const paths = {\n//     path : [[1,2,3,4,5], [1,2,6,5]],\n//     pathGain : [100, 20]\n// }\n\n// console.log(\"test---------------------\");\n// console.log(transferFunction(paths, loops));"]}]}